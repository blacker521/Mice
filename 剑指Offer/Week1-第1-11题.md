## AcWing 13. 找出数组中重复的数字
```c++
/*算法
(数组遍历) O(n)O(n)
首先遍历一遍数组，如果存在某个数不在0到n-1的范围内，则返回-1。

下面的算法的主要思想是把每个数放到对应的位置上，即让 nums[i] = i。

从前往后遍历数组中的所有数，假设当前遍历到的数是 nums[i]=x，那么：

如果x != i && nums[x] == x，则说明 xx 出现了多次，直接返回 x 即可；
如果nums[x] != x，那我们就把 xx 交换到正确的位置上，即 swap(nums[x], nums[i])，交换完之后如果nums[i] != i，则重复进行该操作。由于每次交换都会将一个数放在正确的位置上，所以swap操作最多会进行n次，不会发生死循环。
循环结束后，如果没有找到任何重复的数，则返回-1。

时间复杂度分析
每次swap操作都会将一个数放在正确的位置上，最后一次swap会将两个数同时放到正确位置上，一共只有 n个数和 n个位置，所以swap最多会进行 n−1 次。所以总时间复杂度是 O(n)。
*/
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n = nums.size();
        for(auto x : nums)
            if(x < 0 || x > n)
                return -1;
        for(int i = 0;i < n;i ++)
        {
            while(nums[nums[i]] != nums[i])
                swap(nums[i],nums[nums[i]]);
            if(nums[i] != i) return nums[i];
        }
        return -1;
    }
};
```
## AcWing 14. 不修改数组找出重复的数字
```c++
/*这道题目主要应用了抽屉原理和分治的思想。

抽屉原理：n+1 个苹果放在 n 个抽屉里，那么至少有一个抽屉中会放两个苹果。*/
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int l = 1, r = nums.size() - 1;
        while (l < r) {
            int mid = l + r >> 1; // 划分的区间：[l, mid], [mid + 1, r]
            int s = 0;
            for (auto x : nums) s += x >= l && x <= mid;
            if (s > mid - l + 1) r = mid;
            else l = mid + 1;
        }
        return r;
    }
};
```